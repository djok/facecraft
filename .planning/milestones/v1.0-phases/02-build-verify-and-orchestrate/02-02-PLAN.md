---
phase: 02-build-verify-and-orchestrate
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - docker-compose.yml
autonomous: true

must_haves:
  truths:
    - "docker compose --profile cpu up starts the API and /health returns 200"
    - "docker compose --profile gpu config parses without errors"
    - "Volume mounts configured for /app/uploads and /app/processed persistence"
    - "Environment variables documented inline with sensible defaults"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Production Docker Compose orchestration with CPU and GPU profiles"
      contains: "profiles:"
  key_links:
    - from: "docker-compose.yml"
      to: "djok/facecraft:cpu"
      via: "image reference in cpu service"
      pattern: "image: djok/facecraft:cpu"
    - from: "docker-compose.yml"
      to: "djok/facecraft:gpu"
      via: "image reference in gpu service"
      pattern: "image: djok/facecraft:gpu"
    - from: "docker-compose.yml"
      to: "docker/Dockerfile.cpu"
      via: "build context in cpu service"
      pattern: "dockerfile: docker/Dockerfile.cpu"
    - from: "docker-compose.yml"
      to: "docker/Dockerfile.gpu"
      via: "build context in gpu service"
      pattern: "dockerfile: docker/Dockerfile.gpu"
---

<objective>
Write a production docker-compose.yml at repo root with CPU and GPU profiles, inline environment variable documentation, named volume mounts, and GPU device reservation — then validate syntax and test the CPU profile end-to-end.

Purpose: A working docker-compose.yml is the primary interface for production deployment. Users run `docker compose --profile cpu up` or `docker compose --profile gpu up` and everything works. This is the final orchestration layer.
Output: A validated docker-compose.yml that passes syntax checks and starts the CPU service successfully.
</objective>

<execution_context>
@/home/rosen/.claude/get-shit-done/workflows/execute-plan.md
@/home/rosen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-build-verify-and-orchestrate/02-RESEARCH.md
@.planning/phases/02-build-verify-and-orchestrate/02-01-SUMMARY.md
@docker/Dockerfile.cpu
@docker/Dockerfile.gpu
@src/facecraft/core/config.py
@.env.example
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create docker-compose.yml with profiles, volumes, and inline docs</name>
  <files>docker-compose.yml</files>
  <action>
Create `docker-compose.yml` at repo root. Follow the research template from `02-RESEARCH.md` with these specifics:

**Structure rules:**
- No `version:` key (obsolete since Compose v2.25.0, produces warnings)
- Two services: `facecraft-cpu` (profile: cpu) and `facecraft-gpu` (profile: gpu)
- Both services must have `profiles:` assigned — no "always-on" service
- Both share the same host port mapping: `8000:8000`

**Each service must include:**

1. **Build configuration:**
   - `context: .` (repo root — Dockerfiles reference files relative to repo root)
   - `dockerfile: docker/Dockerfile.cpu` or `docker/Dockerfile.gpu`
   - `image: djok/facecraft:cpu` or `djok/facecraft:gpu` (used when pre-built images exist)

2. **Port mapping:** `"8000:8000"`

3. **Named volume mounts** (COMP-03):
   - `uploads:/app/uploads`
   - `processed:/app/processed`

4. **Environment variables** (COMP-04) — inline YAML comments explaining each:
   - `FACECRAFT_HOST: "0.0.0.0"` — Bind address (always 0.0.0.0 inside container)
   - `FACECRAFT_PORT: "8000"` — API port
   - `FACECRAFT_WORKERS: "1"` — Uvicorn workers (increase for production load)
   - `FACECRAFT_DEVICE: "cpu"` for CPU service, `"auto"` for GPU service
   - `FACECRAFT_LOG_LEVEL: "INFO"` — Logging level (DEBUG, INFO, WARNING, ERROR)

5. **Healthcheck:**
   - `test: ["CMD", "curl", "-f", "http://localhost:8000/health"]`
   - `interval: 30s`, `timeout: 10s`, `start_period: 180s`, `retries: 3`

6. **Restart policy:** `restart: unless-stopped`

**GPU service additional config** (COMP-02):
```yaml
deploy:
  resources:
    reservations:
      devices:
        - driver: nvidia
          count: all
          capabilities: [gpu]
```
Plus NVIDIA env vars:
- `NVIDIA_VISIBLE_DEVICES: "all"`
- `NVIDIA_DRIVER_CAPABILITIES: "compute,utility"`

**Top-level volumes declaration:**
```yaml
volumes:
  uploads:
  processed:
```

**Important — do NOT:**
- Add a `version:` key
- Use `runtime: nvidia` (legacy approach)
- Mix `count` and `device_ids` in GPU devices
- Leave either service without a `profiles:` attribute
  </action>
  <verify>
File exists at repo root:
```bash
test -f docker-compose.yml && echo "EXISTS" || echo "MISSING"
```
Contains required patterns:
```bash
grep -c "profiles:" docker-compose.yml  # Should be 2
grep -c "volumes:" docker-compose.yml   # Should be 3 (2 service-level + 1 top-level)
grep "capabilities:" docker-compose.yml # Should show [gpu]
grep "version:" docker-compose.yml      # Should return nothing (no matches)
```
  </verify>
  <done>docker-compose.yml exists at repo root with two profiled services (cpu/gpu), named volumes for uploads and processed, inline env var comments, GPU device reservation, and no version key.</done>
</task>

<task type="auto">
  <name>Task 2: Validate compose syntax and test CPU profile</name>
  <files>docker-compose.yml</files>
  <action>
Run the validation and testing sequence:

1. **Syntax validation** — catches all schema errors without starting services:
```bash
docker compose config --quiet
```
Exit code 0 = valid. Non-zero means YAML or schema error — fix before proceeding.

2. **GPU profile syntax validation** — validates GPU deploy syntax without needing a GPU:
```bash
docker compose --profile gpu config --quiet
```
Must exit 0. This is the Phase 2 SC-4 test: "no compose errors on parse."

3. **CPU profile end-to-end test** — starts the service and checks /health:
```bash
docker compose --profile cpu up -d
```
Wait for the service to become healthy (healthcheck has 180s start-period for model loading):
```bash
# Poll /health every 10 seconds for up to 200 seconds
for i in $(seq 1 20); do
  if curl -sf http://localhost:8000/health; then
    echo "Health check passed"
    break
  fi
  echo "Waiting for service... ($i/20)"
  sleep 10
done
```
Then verify /health returns 200:
```bash
curl -f http://localhost:8000/health
```
Expected response: `{"status":"healthy"}` (or similar JSON with 200 status).

4. **Volume mount verification** — confirm volumes are created:
```bash
docker volume ls | grep -E "uploads|processed"
```

5. **Tear down:**
```bash
docker compose --profile cpu down
```

If `docker compose config` fails, check for YAML indentation issues (the most common problem). If the CPU profile test fails to reach /health, check container logs with `docker compose --profile cpu logs` to diagnose startup issues.

If the compose file references images that need building, run `docker compose --profile cpu build` first (though 02-01 should have already built them).
  </action>
  <verify>
```bash
docker compose config --quiet && echo "VALID" || echo "INVALID"
docker compose --profile gpu config --quiet && echo "GPU VALID" || echo "GPU INVALID"
```
Both must print VALID (exit code 0).
The /health endpoint must have returned 200 during the CPU profile test.
  </verify>
  <done>docker compose config validates both profiles without errors. CPU profile starts successfully and /health returns 200. Volumes are created. GPU profile syntax parses correctly.</done>
</task>

</tasks>

<verification>
Phase 2 success criteria addressed by this plan:
- SC-3: `docker compose --profile cpu up` starts the API and `/health` returns 200 (Task 2, step 3)
- SC-4: `docker compose --profile gpu up` has correct deploy.resources.reservations.devices syntax, no compose errors on parse (Task 2, step 2)
- COMP-01: Single docker-compose.yml with CPU and GPU profiles (Task 1)
- COMP-02: GPU service with deploy.resources.reservations.devices (Task 1)
- COMP-03: Volume mounts for /app/uploads and /app/processed (Task 1)
- COMP-04: Environment variables documented inline (Task 1)
</verification>

<success_criteria>
- docker-compose.yml exists at repo root with no `version:` key
- Two services: facecraft-cpu (profile: cpu) and facecraft-gpu (profile: gpu)
- `docker compose config --quiet` exits 0
- `docker compose --profile gpu config --quiet` exits 0
- `docker compose --profile cpu up -d` starts the service
- `curl -f http://localhost:8000/health` returns 200
- Named volumes `uploads` and `processed` are created
- GPU service has `deploy.resources.reservations.devices` with `capabilities: [gpu]`
</success_criteria>

<output>
After completion, create `.planning/phases/02-build-verify-and-orchestrate/02-02-SUMMARY.md`
</output>
